!init OPT_LOOK="akopia"; OPT_STYLE="manual" 
# $Id: icprogrammer.sdf,v 1.2 2002-07-26 00:41:13 mheins Exp $

!define DOC_NAME "Interchange Programmer Reference"
!define DOC_TYPE ""
!define DOC_CODE "icprogrammer"
!define DOC_VERSION substr('$Revision: 1.2 $', 11, -2)
!define DOC_STATUS "Draft"
!define DOC_PROJECT "Interchange"
!define DOC_URL "http://interchange.redhat.com/doc/icvars.html"
!define DOC_OWNER "2002 Interchange Developers Group. {{EMAIL:interchange-users@icdevgroup.org}}"

!define SHOW_COMMENTS 0
!define EXAMPLE_SESSION "6CZ2whqo"
!define EXAMPLE_DOMAIN "www.here.com"
!define EXAMPLE_CATALOG "mycatalog"
!define EXAMPLE_VLINK "mycatalog"
!define EXAMPLE_SECURE_DOMAIN "secure.here.com"
!define EXAMPLE_SKU "os28044"
!define EXAMPLE_PRICE 19.99
!define EXAMPLE_SIZE "15oz"
!define EXAMPLE_SIZE1 "10oz"
!define EXAMPLE_SIZE2 "20oz"
!define EXAMPLE_DESCRIPTION "Framing Hammer"
!build_title

H1: Introduction

Interchange is a highly-complex but very powerful web application server
focused on ecommerce. It is built on the power of Perl, using many of its
standard modules and capabilities while defining many more.

While Interchange focuses on e-commerce, it is really a general-purpose
database access, retrieval, and templating systems. Besides online stores,
here are some of the applications have been built on top of it:

!block example
    Auction
    Calendar
    Configuration management
    Content management
    Document archival and rental
    Guestbook
    Image archival and download
    Intranet
    MP3 jukebox
    Poll
    Quiz
    Software repository
    Web log
!endblock

This reference attempts to illuminate the source code of Interchagne
and how you can write Perl enhancements, gadgets, and applications
that integrate with Interchange.

H2: Software installation

To follow along, it is recommended you get the latest release of
Interchange (4.9.1 as of this writing), unpack it from the tar file, and
install it at a private directory. For the purposes of this document, it
will be assumed that Interchange is installed at C</usr/tmp/interchange>
and that the catalogs are installed at C</usr/tmp/catalogs>.

H2: Software prerequisites

Interchange only I<requires> a few added Perl modules, which can
be installed by getting the Perl CPAN bundle C<Bundle::Interchange>.
Install that (usually as root) with:

!block example
	perl -MCPAN -e 'install Bundle::Interchange'
!endblock

To get most of the modules Interchange can use, you can get a more
complete set:

!block example
	perl -MCPAN -e 'install Bundle::InterchangeKitchenSink'
!endblock

H2: Audience

This reference is not meant for casual users of Interchange. Though
they might learn something from reading it, it would probably not
do them much targeted good. A reasonable set of prerequisites to
make reading this document profitable include:

LI1: Programming knowledge

A good knowledge of Perl or B<strong> knowledge of other programming
languages is needed.

LI1: Database knowledge

Interchange is all about databases, and a knowledge of the concepts of
database programming and SQL is strongly recommended.

LI1: Networking knowledge

The more you know about networking and the web, the more comfortable
you will be with this document.

LI1: UNIX knowledge

Almost all production Interchange servers are UNIX-based, so knowledge
of that is helpful.

H1: Overview of Interchange

Interchange is a daemon server, similar to a web server. Its entry
point is usually talking to it over a socket via its own protocol.
That socket can be either UNIX domain or INET domain, or an infinite
number of either.

H2: Catalogs

Interchange as a server dispatches connections to a C<catalog>, an
independently-configurable set of data and templates. These are for
the most part completely independent of each other, though they inherit
common global characteristics and settings. Almost all of those can
be overridden by the catalog.

H2: Hacking

Of course Interchange's source is completely open and available. You
could, if you wished, hack on it all you wanted. However this is strongly
discouraged, for the simple reason that you can override almost any
behavior with configurations and tag definitions of your own. In
fact, if you want to override a core routine you can even do that.

So if you are tempted to hack a routine in the core, simply override
it with:

!block example
GlobalSub <<EOR
sub override_me {
	package Vend::Interpolate;
	sub shipping {
		your_code();
	}
}
EOR

!endblock

H2: ITL -- Interchange Tag Language

Interchange delivers its content by parsing templates that contain
text and ITL, tags in the Interchange Tag Language.

ITL takes the form of HTML-like tags using C<[square brackets]> as
the tag introduction. Here is an ITL tag sequence:

!block example
	[if value name]
	Your name is [value name], in case you forgot.
	[/if]
!endblock

The above will show the contents of the C<[if ...] [/if]> container
providing a non-blank, non-zero value is present in the user
session.

ITL provides direct access to Perl via the ITL container tags
C<[perl]>, C<[calc]> and C<[calcn]>, and C<[mvasp]>. This allows
ITL like:

!block example
	[calc]
		my $out = '';
		if($Values->{name}) {
			$out = "Your name is $Values->{name}, in case you forgot.";
		}
		return $out;
	[/calc]
!endblock

The above is completely identical to the ITL-only snippet above in
effect.

In addition, you can call defined ITL tags in your embedded Perl:

!block example
	[calc]
		my $out = '';
		my $name = $Tag->value('name');
		if($name) {
			$out = "Your name is $Values->{name}, in case you forgot.";
		}
		return $out;
	[/calc]
!endblock

Again, the result is identical to the previous two examples.

H3: User Defined Tags

ITL is comprehensibly extensible. You can produce your own ITL tags that
are fully as powerful as the ones supplied with the distribution. In fact
they are indistinguishable, as you will see when you examine the C<code>
hierarchy.

These tags can use any Perl module, use external programs, or basically
do most anything Perl can, providing you define them in the Global
configuration. Tags defined in the Catalog configuration are restricted
by Perl's standard Opcode and Safe facilities, though they can optionally
be allowed global capability.

See L<ictags> for complete information on ITL.

H2: Talking to Interchange via socket

Interchange can run in any of several modes:

LI1: Foreground

The foreground, meaning the same Interchange server listens for
connections and then runs the tasks those connections cause.

LI1: Forking mode

One master Interchange listens for connections, then forks instances
to handle the tasks those connections cause. The forked instance
terminates at the end of the task.

LI1: Prefork mode

Similar to the way Apache does, Interchange can fork off a number
of instances that all listen to the sockets open for connections. The
first one to answer gets the task, runs it, then returns to listen
again. After MaxChildRequests requests, it dies and causes another
new instance to take its place.

LI1: SOAP mode

Interchange can listen to a socket designed to accept a SOAP connection --
those always run in prefork mode.

H2: Talking to Interchange over the command line

Interchange starts its servers by being invoked from the command line. Other
command line invocations can stop the server via signal, cause addition of
additional catalogs to respond to, remove catalogs from the list to respond
to, or cause execution of "cron" jobs.

H2: Data structure overview

Interchange has three major data stuctures, which correspond to the
master server, the catalog, and the user.

You can examine two of these structures by setting in interchange.cfg:

!block example
	DumpStructure  Yes
!endblock

This will by default dump an interchange.structure file which shows
the global configuration, and a CATALOGNAME.structure file in each 
catalog directory showing that catalog's configuration.

The third structure, the user data session, can be viewed with
the following ITL placed in a page:

!block example
	<XMP>[dump]</XMP>
!endblock

H3: The Global configuration

This is held in a set of variables inhabiting the Global package.
They define overall server behavior, and contain pointers to the
catalog structures.

The Global configuration is defined in C<interchange.cfg> and
any files that it reads via C<include> statements. The configuration is
produced by parsing interchange.cfg with the routine
C<Vend::Config::global_config>.

Directives can be defined for parsing by the catalog configuration
within the global configuration. The only way to define new global
directives is via hacking the source.
but the 
H3: The Catalog configuration

Each Interchange catalog has its own configuration completely
independent from others. It is produced by parsing the file
C<catalog.cfg> in the directory defined as the base for the catalog --
it is parsed by the subroutine C<Vend::Config::config>.


Interchange defines some special variables which control behavior. They
can be of several types, and the conventions for using them depend on
whether you have based your catalog and server on the standard
"foundation" distribution. 

We will distinguish between these by calling intrinsic variables
CORE variables, noting the distribution variables as DISTRIBUTION,
and noting the foundation catalog practices as FOUNDATION.

H2: "Variable" configuration file definitions

Defined in interchange.cfg or catalog.cfg with the C<Variable>
configuration directive, these are accessed with:

!block example
  Access in ITL with           From
  -----------------------      -------------------
  __VARNAME__                  (catalog.cfg only)
  @_VARNAME_@                  (catalog.cfg, falls back to interchange.cfg)
  @@VARNAME@@                  (interchange.cfg only) 
  [var VARNAME]                (catalog.cfg only) 
  [var VARNAME 1]              (interchange.cfg only) 
  [var VARNAME 2]              (catalog.cfg, falls back to interchange.cfg)
                              
  Embedded Perl                From
  -----------------------      -------------------
  $Variable->{VARNAME}         (catalog.cfg only)
  $Tag->var('VARNAME')         (catalog.cfg only)
  $Tag->var('VARNAME', 1)      (interchange.cfg only) 
  $Tag->var('VARNAME', 2)      (catalog.cfg, falls back to interchange.cfg)
  $Global::Variable->{VARNAME} (interchange.cfg only, only in Global code) 
!endblock

Variables set with C<Variable> are not normally modified dynamically, though
you can do it as a part of the C<Autoload> routine or in other code. They will
not retain the value unless C<DynamicVariables> is in use.

H2: Scratch

User scratch variables are initialized whenever a new user session is
created. They start with whatever is defined in the C<ScratchDefault>
directive in catalog.cfg; otherwise they are not defined.

!block example
  Access in ITL with           Attributes
  -----------------------      -------------------
  [scratch varname]            Displays
  [scratchd varname]           Displays and deletes
                              
  Embedded Perl                From
  -----------------------      -------------------
  $Scratch->{varname}          Accessor
  $Session->{scratch}{varname} Equivalent
!endblock

They can be set in several ways:

!block example
  Set in ITL with              Attributes
  -----------------------      -------------------
  [set varname]VAL[/set]       Sets to VAL, no interpretation of ITL inside
  [seti varname]VAL[/seti]     Sets to VAL, interprets ITL inside
  [tmpn varname]VAL[/tmpn]     Sets to VAL, no ITL interpretation, temporary
  [tmp  varname]VAL[/tmp]      Sets to VAL, interprets ITL inside, temporary
                              
  Embedded Perl                From
  -----------------------      -------------------
  $Scratch->{varname} = 'VAL'; Sets to VAL
  $Tag->tmp(varname);          Set as temporary, must set value afterwards.

!endblock

H2: CGI

CGI variables are the raw data which comes from the user.

.WARNING: It is a security risk to use these variables for display
in the page.

You can use them for testing without worry, though you should
never set their value into a database or display on the page unless
you have processed them first, as they can have arbitrary values.
The most common security risk is displaying HTML code, which allows
remote scripting exploits like cookie-stealing.

!block example
    [calc]
        ####  DO NOT DO THIS!!!!
        my $out = $CGI->{varname};
        return $out;
    [/calc]
!endblock

That will transform the value. If you wish to output a safe value but
keep the actual value intact, do:

!block example
    [calc]
        ####  This is safe, makes value safe for rest of page
        my $out = $Tag->cgi( { name => 'varname', filter => 'entities' } );
        ####  This is safe too, doesn't transform value
        my $other = $Tag->filter($CGI->{varname}, 'entities');

        ### Now you can return stuff to the page
        return $out . $other;
    [/calc]
!endblock

The access methods are:

!block example
  Access in ITL with                 Attributes
  -----------------------            -------------------
  [cgi varname]                      Doesn't stop ITL code, don't use!
  [cgi name=varname filter=entities] Use this for safety
                              
  Embedded Perl                From
  -----------------------      -------------------
  $CGI->{varname}              Don't use for output values!
!endblock

They can be set as well.

!block example
  Set in ITL with                       Attributes
  -----------------------               -------------------
  [cgi name=varname set="VAL"]          Sets to VAL, VAL can be ITL, shows VAL
  [cgi name=varname set="VAL" hide=1]   Sets to VAL, VAL can be ITL, no output
                              
  Embedded Perl                From
  -----------------------      -------------------
  $CGI->{varname} = 'VAL';     Sets to VAL, next access to [cgi varname]
                               shows new value

!endblock

H2: Values

User form variables are initialized whenever a new user session is
created. They start with whatever is defined in the C<ValuesDefault>
directive in catalog.cfg; otherwise they are not defined except as
called out in other configuration directives, i.e. the obsolete
DefaultShipping.

!block example
  Access in ITL with           Attributes
  -----------------------      -------------------
  [value varname]              Displays
                              
  Embedded Perl                From
  -----------------------      -------------------
  $Values->{varname}           Accessor
!endblock

They can be set as well, though the normal method of setting is from
user input via form. If Interchange receives an action which performs
the update of values (by default C<go> or C<return>, C<refresh>, or
C<submit>), the value of CGI variables will be transferred to them
subject to other considerations (FormIgnore settings, credit card
variables, etc., discussed below).!block example

!block example
  Set in ITL with                         Attributes
  -----------------------                 -------------------
  [value name=varname set="VAL"]          Sets to VAL, VAL can be ITL, shows VAL
  [value name=varname set="VAL" hide=1]   Sets to VAL, VAL can be ITL, no output
                              
  Embedded Perl                           Attributes
  -----------------------                 -------------------
  $Values->{varname} = 'VAL';             Sets to VAL, next access to
                                          [value varname] shows new value
!endblock

H2: Session variables

You can also directly access the user session. Normally you don't set these
values unless you are an experienced Interchange programmer, but there are
several values that are frequently used.

One example is C<username>, which holds the logged-in user's username.

!block example
  Access in ITL with           Attributes
  -----------------------      -------------------
  [data session username]      Displays
                              
  Embedded Perl                From
  -----------------------      -------------------
  $Session->{username}         Accessor
!endblock

They can be set as well, but if you are experienced enough to contemplate
doing these things you will easily be able to figure it out.

H2: Values not transmitted from CGI

The following variables are never copied from CGI:

!block example
	mv_todo
	mv_todo.submit.x
	mv_todo.submit.y
	mv_todo.return.x
	mv_todo.return.y
	mv_todo.checkout.x
	mv_todo.checkout.y
	mv_todo.todo.x
	mv_todo.todo.y
	mv_todo.map
	mv_doit
	mv_check
	mv_click
	mv_nextpage
	mv_failpage
	mv_successpage
	mv_more_ip
	mv_credit_card_number
	mv_credit_card_cvv2
!endblock

You can define more with the C<FormIgnore> catalog.cfg directive.

H2: Global program variables

If you are programming a GlobalSub or global UserTag, you have access
to all Interchange facilities including all the preset variables and
configuration directives.

The C<Global> package is used to hold variables that are set at
program start and whose value is retained.

The C<Vend> package is used for variables that might be set at some
point during program execution, but that will always be reset to 
undefined at the end of the transaction.

One example is $Vend::Cookie, which holds the raw cookie value
sent by the user. 

If you are going to set or access these variables, you should be
getting your documentation from the source code. A few will be 
shown here, but most will not.

H1: Variable listing

H2: Standard global (interchange.cfg) Variable values


